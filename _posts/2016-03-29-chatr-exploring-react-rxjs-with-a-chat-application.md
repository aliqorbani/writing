---
ID: 4875
post_title: 'Chatr: Exploring React &#038; RxJS with a Chat Application'
author: James DiGioia
post_date: 2016-03-29 13:37:22
post_excerpt: ""
layout: post
permalink: >
  http://jamesdigioia.com/chatr-exploring-react-rxjs-with-a-chat-application/
published: true
---
<p><a href="https://facebook.github.io/react/">React.js</a> has pretty well skyrocketed through the JavaScript community since its initial announcement, and with its reactive approach to UI, there's been a growing interest in functional programming in the JavaScript community as a result. Because JavaScript allows you to pass functions around like objects, it makes it very easy to apply functional concepts to the language. Like much of the community, I've also been <a href="https://medium.com/@chetcorcos/functional-programming-for-javascript-people-1915d8775504#.2bmh3geet">reading</a> <a href="http://fr.umio.us/favoring-curry/">quite</a> <a href="http://fr.umio.us/why-ramda/">a bit</a> about <a href="https://github.com/timoxley/functional-javascript-workshop">functional programming</a>, but I haven't had the opportunity to build a full-fledged application on these ideas.</p>
<p>I've played around with <a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a> &amp; React[^1] a little bit, but I'm not entirely sure what a full-stack architecture might look like (yet). I want to explore the possibilities by building a real-time chat application (with the uninspiring name Chatr) on Node.js with RxJS, React, &amp; <a href="http://ramdajs.com/0.19.1/index.html">Ramda</a>, applying functional programming to a system that can easily be modeled as a stream of messages/events.</p>
<p>With RxJS, I should be able pipe messages around the application, including into React to update the UI on the client side, as well as to and from a data store like <a href="http://redis.io/">Redis</a> or a messaging queue like <a href="https://www.rabbitmq.com/">RabbbitMQ</a> on the server side, with the data streaming between the server &amp; client over a Socket.io stream. This architecture could also be inspired by <a href="https://facebook.github.io/flux/">Flux</a>, ensuring all data flows into a central &quot;store stream,&quot; which then pipes out the messages to wherever it needs to go. This primary data store stream probably could be reused on both the client &amp; server side, which allows us to introduce some isomorphism in both our data handling &amp; UI.</p>
<p>My plan is to build this in public and write about it, and see what some of the advantages and drawbacks of this approach for building web applications. You can follow along with <a href="https://github.com/mAAdhaTTah/chatr">the repo on GitHub</a>, or keep up with the <a href="http://jamesdigioia.com/thread/rxjs-react-w-chatr/">thread on this website</a>.</p>
<p>Before we can get started doing anything interesting, we've got to get some boilerplate going. Since we want to try out some isomorphic techniques, we're going to need to, at a minimum, get the JSX compiled on the server side. <a href="https://babeljs.io/"><code>babel</code></a> is the default standard for compiling JSX, and they have a very clear <a href="https://github.com/babel/example-node-server">example</a> for getting it running on the server. Since we're already using it, we're also going to bring in ES6 compilation and use that for both the server- and client-side code.</p>
<p>Following along with the example, we're going to add <code>nodemon</code>, <code>babel-cli</code>, and the two babel presets we're going to use, <code>babel-preset-es2015</code> and <code>babel-preset-react</code>. Since we're going to be sharing the <code>babel</code> configuration between the server and client, we need a <code>.babelrc</code> file, which <code>babel</code> uses to register presets and plugins:</p>
<p>http://jamesdigioia.com/gistpens/chatr-boilerplate/babelrc-2/</p>
<p>Finally, add <code>nodemon server.js --exec babel-node</code> to the <code>package.json</code>'s scripts key as <code>&quot;start&quot;</code>, so we can run <code>npm start</code> to run the server. <code>babel-node</code> is shipped with the <code>babel-cli</code> package we installed, and it ensures our server-side code is compiled on-the-fly by <code>babel</code> and then run in <code>node</code>, with <code>nodemon</code> recompiling and restarting the server whenever our code changes.</p>
<p>We're going to use <a href="http://expressjs.com/">express.js</a> to handle routing and serve our static assets. Let's create the <code>server.js</code> file and get some simple routes going:</p>
<p>http://jamesdigioia.com/gistpens/chatr-boilerplate/server-js-2/</p>
<p>Pretty basic express server; run <code>npm start</code> in your terminal and then go to <a href="http://localhost:3000/">localhost:3000</a>. You should see a big &quot;Hello World!&quot;. Got it? Good! Let's get some script and style compilation going.</p>
<p>We'll start with the scripts. <a href="https://webpack.github.io/"><code>webpack</code></a> and <a href="http://browserify.org/"><code>browserify</code></a> are both solid options for compiling scripts using <code>babel</code>. I've used <code>browserify</code> a lot more than I've used <code>webpack</code>, so I'm going to use <code>webpack</code> for this project. Fortunately, the configuration isn't that complicated for a simple setup like this:</p>
<p>http://jamesdigioia.com/gistpens/chatr-boilerplate/webpack-config-js-2/</p>
<p>We're not going to worry about getting any of the really complicated features setup, like hot reloading or dev servers or anything like that. Instead, we're going start with to create a simple script that uses some ES6 to ensure that we're compiling our scripts correctly.</p>
<p>http://jamesdigioia.com/gistpens/chatr-boilerplate/client-js-2/</p>
<p>If you've <code>npm install</code>ed <code>webpack</code>, you can just run <code>webpack</code> in your terminal and it should spit out a <code>main.min.js</code> file in your <code>public</code> folder. Pull that up in your <a href="http://localhost:3000/main.min.js">browser</a> and you should see the compiled file.</p>
<p>On the style side, we can compile our <code>styles.scss</code> file with <code>node-sass</code>. I'm going to be including <a href="http://bourbon.io/">Bourbon</a>, <a href="http://neat.bourbon.io/">Neat</a>, and <a href="http://bitters.bourbon.io/">Bitters</a> for this project, as I like their mixin-only approach for its flexibility and control. Here's the very basic <code>styles.scss</code> file:</p>
<p>http://jamesdigioia.com/gistpens/chatr-boilerplate/styles-scss-2/</p>
<p>I'd love to get this setup with <a href="http://eyeglass.rocks/">Eyeglass</a> as well, but we'll start with this. Install <code>node-sass</code> and run <code>node-sass styles.scss public/styles.css</code>. We <a href="http://localhost:3000/styles.css">should see</a> the CSS file rendered, compressed and compiled correctly, with a long sourcemap appended at the end.</p>
<p>Finally, we're going to convert the root route to render a template for us instead of using a simple string. In this case, we're going to register <a href="http://handlebarsjs.com/">Handlebars</a> using <a href="https://github.com/ericf/express-handlebars"><code>express-handlebars</code></a>:</p>
<p>http://jamesdigioia.com/gistpens/chatr-boilerplate/handlebars-2/</p>
<p>which we're going to use to render a very simple template:</p>
<p>http://jamesdigioia.com/gistpens/chatr-boilerplate/main-hbs-2/</p>
<p>This is set up this way in preparation for implementing is server-side rendering! The <code>app</code> variable in the template context will become the rendered HTML string from React, and the <code>state</code> variable will be the state object that produced the given HTML. Then on the client side, we'll pull in current state, render the React components on the current state on the page, and bootstrap the application. This is how the <a href="https://github.com/reactjs/redux/blob/master/docs/recipes/ServerRendering.md">Redux docs</a> suggest doing it, and since they know what they're doing, we're going to follow their lead.</p>
<p>But we're going to wire that up in the next tutorial. For now, you should have a simple page page, rendering &quot;Hello World!&quot;, with a CSS file and a script that outputs <code>3</code> to the console. Next, we're going to write our first React component, render it on the server, and bootstrap our application.</p>
<p>[^1]: In the next version of WP-Gistpen, the settings page is built with React &amp; RxJS.</p>